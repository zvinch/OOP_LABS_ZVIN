// Темы:
// Простое наследование. Виртуальные функции. Абстрактные классы.
// Битовые поля.


#include <tchar.h>
#define	  stop __asm nop

#include "shape.h"
#include "myRect.h"
#include "circle.h"
#include "myByte.h"

int _tmain(int argc, _TCHAR* argv[])
{


	////Задание 1.Простое наследование.Аргументы конструктора,
	//// передаваемые в базовый класс.

	////Создайте иерархию классов:
	////базовый класс Shape (который описывает любую фигуру)
	////и два производных класса Rect и Circle.
	////Подумайте: какие данные и методы нужно ввести в базовый
	////и производные классы (например, любую фигуру можно сделать
	////цветной => в базовом классе можно ввести переменную, которая
	////будет определять цвет фигуры.
	////Подсказка: для хранения цвета объявите перечисление (RED,GREEN,BLUE...);

	//Shape sh1;
	//Rect rect1;
	//rect1.SetAll(1, 2, 3, 4);
	//rect1.SetColor(myColor::BLUE);
	//Circle ball(3, 3, 1);


	////В конструкторах производных классов предусмотрите передачу
	////параметра-цвета конструктору базового класса.
	////При создании и уничтожении объекта производного типа определите
	////последовательность вызовов конструкторов и деструкторов базового
	////и производного классов

	//Rect rect2(3, 4, 5, 6, myColor::BLUE);
	//stop;
	//// отец->сын ~сын->отец




	stop
		//////////////////////////////////////////////////////////////////////

		//Задание 2.Виртуальные функции.
		//2а) Модифицируйте классы Shape,Rect и Circle:
		//добавьте в каждый класс public метод void WhereAmI().
		//Реализация каждой функции должна выводить сообщение 
		//следующего вида "Now I am in class Shape(Rect или Circle)".
		//Выполните приведенный фрагмент, объясните результат.

		//2б) Сделайте метод WhereAmI() виртуальным.
		//Снова выполните приведенный фрагмент, объясните разницу.

	//{
	//	Shape s;
	//	Rect r;
	//	Circle c;


	//	//Метод какого класса вызывается в следующих строчках???
	//	s.WhereAmI();	//	??? Shape                                               
	//	r.WhereAmI();	//	??? Rect
	//	c.WhereAmI();	//	??? cIRCLE
	//	stop


	//	Shape* pShape = &s;
	//	Shape* pRect = &r;
	//	Shape* pCircle = &c;
	//	pShape->WhereAmI();	//	??? shape                                               shape             
	//	pRect->WhereAmI();	//	??? shape												rect
	//	pCircle->WhereAmI(); //	??? shape потому что видно только шейп					circle

	//	stop


	//		//Заполните ... согласно комментариям
	//		Shape& rShape = s; //псевдоним s
	//	Shape& rRect = r; //псевдоним r
	//	Shape& rCircle = c; //псевдоним c
	//	(rShape).WhereAmI();	//вызов посредством rShape	??? shape                  shape	
	//	(rRect).WhereAmI();	//вызов посредством	rRect	??? shape						rect
	//	(rCircle).WhereAmI(); //вызов посредством rCircle	??? shape					circle
	//	stop
	//}


	//////////////////////////////////////////////////////////////////////

	//Задание 3.Виртуальные деструкторы.
	//Модифицируйте классы:
	//a) введите соответствующие
	// деструкторы (без ключевого слова virtual).
	//Реализация каждого деструктора
	//должна выводить сообщение следующего вида
	// "Now I am in Shape's destructor!" или
	// "Now I am in Rect's destructor!"
	//Выполните фрагмент. Объясните результат.
	stop
		//{
		//	Shape s;       //удаляються в порядке обратном созданию и используються все и разницы нет
		//	Rect r;
		//	Circle c;
		//}
			stop
			// b) Добавьте в объявление деструкторов ключевое слово virtual 
			//Выполните фрагмент.Объясните разницу.


			//Подумайте: какие конструкторы вызываются в следующей строке?
			//Если в разработанных классов каких-то конструкторов
			//не хватает - реализуйте
			//Если Вы считаете, что в приведенном фрагменте чего-то
			//не хватает - добавьте
			stop
	/*	{
			Rect r(1, 2, 3, 4, GREEN);
			Shape* ar[] = { new Shape(r), new Rect(r), new Circle(r), new Circle() };
			for (int i = 0; i < 4; i++)
			{
				(*ar[i]).WhereAmI();
			}

			for (int i = 0; i < 4; i++)
			{
				delete ar[i];
			}
		}*/
			stop
		//Вызовите для каждого элемента массива метод WhereAmI()
	

	stop



	//Задание 4*. В чем заключается отличие 1) и 2)
	//{
	//	Shape* pShapes = new Rect[10];//1)
	//	Rect* pRects = new Rect[10];//2)
	// 
	//	//Попробуйте вызвать метод WhereAmI() для каждого элемента обоих массивов -
	//	//в чем заключается проблема???
	//	
	//	

	//	for (int i = 0; i < 10; i++)
	//	{
	//	//	Rect* tmp = static_cast<Rect*> (&pShapes[i]);
	//		//(*tmp).WhereAmI();
	//		static_cast<Rect*> (pShapes)[i].WhereAmI();
	//		pRects[i].WhereAmI();
	//	}
	//	stop

	//	//Освободите динамически захваченную память
	//	
	//	delete[] pShapes;
	//	delete[] pRects;
	//	
	//stop	
	//}



//////////////////////////////////////////////////////////////////////

	////Задание 5.Виртуальные функции и оператор разрешения области видимости. 

	{
		//Rect r;
		//Shape* p = &r;	
		//p->WhereAmI();//...
		//stop
	
		//
		////4a Оператор разрешения области видимости.
		////Посредством объекта r и указателя p вызовите виртуальную функцию
		////WhereAmI()класса Shape
		//Shape* p2 = &r;
		//p->Shape::WhereAmI();
		//stop
		//	
			
	}


//////////////////////////////////////////////////////////////////////

	//Задание 6.Чисто виртуальные функции. 
	//Введите в базовый класс метод void Inflate(int); Подумайте:
	//можно ли реализовать такой метод для базового класса? => как его нужно объявить.
	//Реализуйте этот метод для производных классов.
	{
		Rect r(1,2,3,4);
		Shape* p = &r;
		p->Inflate(5);
		Circle c(3,3,1);
		p = &c;
		p->Inflate(5);
		stop
	}
	stop

//////////////////////////////////////////////////////////////////////

	//Задание 7.Объединения (union) C++. Битовые поля.
	//1.
	//Создайте следующие классы для различных представлений значений байта:
	//Bin - для двоичного представления
	//Hex - для шестнадцатерчного представления
	//Oct - для восьмеричного представления.
	//Подсказка 1: - для удобства используйте битовые поля.
	//Подсказка 2: - конструкторов в таких вспомогательных классах быть не должно,
	//так как все они будут членами объединения (union).
	//2.
	//В каждом классе введите метод Show, который должен выводить значение в
	//соответствующем виде
	//3.
	//Посредством объединения MyByte предоставьте пользователю возможность манипулировать
	//одним и тем же значением по-разному:
	//а) выводить: десятичное, шестнадцатеричное, восьмеричное, двоичное значение байта 
	//          а также символ, соответствующий хранимому значению (если есть соответствие);
	//б) выводить отдельные (указанные посредством параметра) шестнадцатеричные,
	//			восьмеричные, двоичные цифры;
	//в) изменять отдельные двоичные, восьмеричные или шестнадцатеричные цифры;

	MyByte byte(0x1f);
	byte.ShowHex();
	byte.ShowBin();
	byte.ShowOct();

	byte.ShowBin();
	byte.ShowBitBin(3);
	byte.ShowBin();
	byte.ShowHex();
	byte.ShowOct();
	byte.SetBit(2, 0);
	byte.ShowBin();
	byte.ShowHex();
	byte.ShowOct();

	byte.SetBit(2, 1);
	byte.ShowBin();
	byte.ShowHex();
	byte.ShowOct();

	byte.SetHex(1, 0xA);
	byte.ShowBin();
	byte.ShowHex();
	byte.ShowOct();
	byte.SetHex(1, 1);
	byte.ShowBin();
	byte.ShowHex();
	byte.ShowOct();

	

	byte.SetOct(1, 4);

	byte.ShowBin();
	byte.ShowHex();
	byte.ShowOct();

	byte.SetOct(1, 3);


	byte.ShowBin();
	byte.ShowHex();
	byte.ShowOct();
	
	//...
	stop




	
	return 0;
}//endmain

